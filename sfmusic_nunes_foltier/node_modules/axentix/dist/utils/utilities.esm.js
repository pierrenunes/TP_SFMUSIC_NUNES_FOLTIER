const a = [], l = {
  components: [],
  plugins: [],
  prefix: "ax",
  mode: ""
}, u = (t) => l.components.find((e) => e.name === t).class, g = () => {
  const t = l.components.filter((n) => n.dataDetection), e = l.plugins.filter((n) => n.dataDetection);
  return [...t, ...e].map((n) => n.name);
}, f = (t) => t.replace(/[\w]([A-Z])/g, (e) => e[0] + "-" + e[1]).toLowerCase(), m = (t, e = "") => {
  const n = f(t);
  return e ? e + "-" + n : n;
}, y = (t, e, n, o, s = "") => {
  const r = e[0].toUpperCase() + e.slice(1).toLowerCase();
  g().includes(r) && n !== "Collapsible" && r !== "Sidenav" && (t[e] = u(r).getDefaultOptions());
  const c = s ? s + "-" + e : e, i = p(t[e], n, o, c);
  if (!(Object.keys(i).length === 0 && t.constructor === Object))
    return i;
}, p = (t, e, n, o = "") => Object.keys(t).reduce((s, r) => {
  if (typeof t[r] == "object" && t[r] !== null) {
    const c = y(t, r, e, n, o);
    c && (s[r] = c);
  } else if (t[r] !== null) {
    const c = "data-" + e.toLowerCase() + "-" + m(r, o);
    if (n.hasAttribute(c)) {
      const i = n.getAttribute(c);
      s[r] = typeof t[r] == "number" ? Number(i) : i, typeof t[r] == "boolean" && (s[r] = i === "true");
    }
  }
  return s;
}, {}), x = (t, e) => {
  const n = Object.assign({}, u(t).getDefaultOptions());
  return p(n, t, e);
}, T = () => {
  document.querySelectorAll("[data-ax]").forEach((e) => {
    let n = e.dataset.ax;
    if (n = n[0].toUpperCase() + n.slice(1).toLowerCase(), !g().includes(n)) {
      console.error(
        `[Axentix] Error: ${n} component doesn't exist. 
 Did you forget to register him ?`,
        e
      );
      return;
    }
    try {
      const o = u(n);
      new o(`#${e.id}`);
    } catch (o) {
      console.error("[Axentix] Data: Unable to load " + n, o);
    }
  });
}, v = () => {
  try {
    new Axentix.Axentix("all");
  } catch (t) {
    console.error("[Axentix] Unable to auto init.", t);
  }
};
document.addEventListener("DOMContentLoaded", () => {
  document.documentElement.dataset.axentix && v(), T();
});
const h = (...t) => t.reduce((e, n) => {
  for (let o in n)
    e[o] = typeof n[o] == "object" && n[o] !== null ? h(e[o], n[o]) : n[o];
  return e;
}, {}), A = (t, e, n) => h(u(t).getDefaultOptions(), x(t, n), e), O = (t, e = document.createElement("div")) => (t[0].parentElement.insertBefore(e, t[0]), t.forEach((o) => e.appendChild(o)), e), D = (t) => t.replaceWith(...t.childNodes), E = (t, e, n) => {
  const o = new CustomEvent("ax." + e, {
    detail: n || {},
    bubbles: !0
  });
  t.dispatchEvent(o);
}, w = () => "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0, C = () => !!window.PointerEvent && "maxTouchPoints" in window.navigator && window.navigator.maxTouchPoints >= 0, L = () => w() ? "touch" : C() ? "pointer" : "mouse", P = (t) => a.filter((e) => e.type === t).map((e) => e.instance), d = (t) => {
  const e = a.find((n) => n.type !== "Toast" && "#" + n.instance.el.id === t);
  return e ? e.instance : !1;
}, b = () => Math.random().toString().split(".")[1], k = () => a, M = (t) => d(t).sync(), I = () => a.map((t) => t.instance.sync()), S = (t) => d(t).reset(), U = () => a.map((t) => t.instance.reset()), N = (t) => d(t).destroy(), X = () => a.map((t) => t.instance.destroy()), Y = (t, e, n, o) => {
  const s = t && e ? document.querySelector(`.ax-overlay[data-target="${n}"]`) : document.createElement("div");
  return s.classList.add("ax-overlay"), s.style.transitionDuration = o + "ms", s.dataset.target = n, s;
}, q = (t, e, n, o, s) => {
  !t || (o ? (e.addEventListener("click", n), document.body.appendChild(e), setTimeout(() => {
    e.classList.add("active");
  }, 50)) : (e.classList.remove("active"), setTimeout(() => {
    e.removeEventListener("click", n), document.body.removeChild(e);
  }, s)));
}, $ = (t, e = '[data-target="{ID}"]') => Array.from(document.querySelectorAll(e.replace("{ID}", t))), B = (t) => t.targetTouches && t.targetTouches.length >= 1 ? t.targetTouches[0].clientY : t.changedTouches && t.changedTouches.length >= 1 ? t.changedTouches[0].pageY : t.clientY, F = (t) => t.targetTouches && t.targetTouches.length >= 1 ? t.targetTouches[0].clientX : t.changedTouches && t.changedTouches.length >= 1 ? t.changedTouches[0].pageX : t.clientX, W = () => window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
export {
  E as createEvent,
  Y as createOverlay,
  N as destroy,
  X as destroyAll,
  h as extend,
  k as getAllInstances,
  F as getClientXPosition,
  B as getClientYPosition,
  A as getComponentOptions,
  d as getInstance,
  P as getInstanceByType,
  L as getPointerType,
  $ as getTriggers,
  b as getUid,
  W as isDarkMode,
  C as isPointerEnabled,
  w as isTouchEnabled,
  S as reset,
  U as resetAll,
  M as sync,
  I as syncAll,
  D as unwrap,
  q as updateOverlay,
  O as wrap
};
