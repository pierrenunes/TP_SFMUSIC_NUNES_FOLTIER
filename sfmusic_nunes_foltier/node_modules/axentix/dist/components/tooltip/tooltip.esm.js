var F = Object.defineProperty;
var H = (i, s, t) => s in i ? F(i, s, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[s] = t;
var E = (i, s, t) => (H(i, typeof s != "symbol" ? s + "" : s, t), t), R = (i, s, t) => {
  if (!s.has(i))
    throw TypeError("Cannot " + t);
};
var e = (i, s, t) => (R(i, s, "read from private field"), t ? t.call(i) : s.get(i)), p = (i, s, t) => {
  if (s.has(i))
    throw TypeError("Cannot add the same private member more than once");
  s instanceof WeakSet ? s.add(i) : s.set(i, t);
}, l = (i, s, t, o) => (R(i, s, "write to private field"), o ? o.call(i, t) : s.set(i, t), t);
var u = (i, s, t) => (R(i, s, "access private method"), t);
const C = [], L = {
  components: [],
  plugins: [],
  prefix: "ax",
  mode: ""
}, I = (i) => L.components.find((s) => s.name === i).class, S = () => {
  const i = L.components.filter((t) => t.dataDetection), s = L.plugins.filter((t) => t.dataDetection);
  return [...i, ...s].map((t) => t.name);
}, M = (i, s) => {
  if (!i.name || !i.class) {
    console.error(`[Axentix] Error registering ${s} : Missing required parameters.`);
    return;
  }
  if (L[s].some((t) => t.name === i.name)) {
    console.error(`[Axentix] Error registering ${s} : Already exist.`);
    return;
  }
  i.autoInit && (i.autoInit.selector = i.autoInit.selector += ":not(.no-axentix-init)"), L[s].push(i);
}, Y = (i) => {
  M(i, "components");
}, X = (i) => i.replace(/[\w]([A-Z])/g, (s) => s[0] + "-" + s[1]).toLowerCase(), Z = (i, s = "") => {
  const t = X(i);
  return s ? s + "-" + t : t;
}, G = (i, s, t, o, a = "") => {
  const r = s[0].toUpperCase() + s.slice(1).toLowerCase();
  S().includes(r) && t !== "Collapsible" && r !== "Sidenav" && (i[s] = I(r).getDefaultOptions());
  const d = a ? a + "-" + s : s, g = k(i[s], t, o, d);
  if (!(Object.keys(g).length === 0 && i.constructor === Object))
    return g;
}, k = (i, s, t, o = "") => Object.keys(i).reduce((a, r) => {
  if (typeof i[r] == "object" && i[r] !== null) {
    const d = G(i, r, s, t, o);
    d && (a[r] = d);
  } else if (i[r] !== null) {
    const d = "data-" + s.toLowerCase() + "-" + Z(r, o);
    if (t.hasAttribute(d)) {
      const g = t.getAttribute(d);
      a[r] = typeof i[r] == "number" ? Number(g) : g, typeof i[r] == "boolean" && (a[r] = g === "true");
    }
  }
  return a;
}, {}), J = (i, s) => {
  const t = Object.assign({}, I(i).getDefaultOptions());
  return k(t, i, s);
}, K = () => {
  document.querySelectorAll("[data-ax]").forEach((s) => {
    let t = s.dataset.ax;
    if (t = t[0].toUpperCase() + t.slice(1).toLowerCase(), !S().includes(t)) {
      console.error(
        `[Axentix] Error: ${t} component doesn't exist. 
 Did you forget to register him ?`,
        s
      );
      return;
    }
    try {
      const o = I(t);
      new o(`#${s.id}`);
    } catch (o) {
      console.error("[Axentix] Data: Unable to load " + t, o);
    }
  });
}, Q = () => {
  try {
    new Axentix.Axentix("all");
  } catch (i) {
    console.error("[Axentix] Unable to auto init.", i);
  }
};
document.addEventListener("DOMContentLoaded", () => {
  document.documentElement.dataset.axentix && Q(), K();
});
const q = (...i) => i.reduce((s, t) => {
  for (let o in t)
    s[o] = typeof t[o] == "object" && t[o] !== null ? q(s[o], t[o]) : t[o];
  return s;
}, {}), P = (i, s, t) => q(I(i).getDefaultOptions(), J(i, t), s), v = (i, s, t) => {
  const o = new CustomEvent("ax." + s, {
    detail: t || {},
    bubbles: !0
  });
  i.dispatchEvent(o);
}, W = (i) => {
  const s = C.find((t) => t.type !== "Toast" && "#" + t.instance.el.id === i);
  return s ? s.instance : !1;
};
class _ {
  constructor() {
    E(this, "el");
  }
  removeListeners() {
  }
  setupListeners() {
  }
  setup() {
  }
  preventDbInstance(s) {
    if (s && W(s))
      throw new Error(`Instance already exist on ${s}`);
  }
  sync() {
    v(this.el, "component.sync"), this.removeListeners(), this.setupListeners();
  }
  reset() {
    v(this.el, "component.reset"), this.removeListeners(), this.setup();
  }
  destroy() {
    v(this.el, "component.destroy"), this.removeListeners();
    const s = C.findIndex((t) => t.instance.el.id === this.el.id);
    C.splice(s, 1);
  }
}
const j = {
  content: "",
  animationDelay: 0,
  offset: "10px",
  animationDuration: 200,
  classes: "grey dark-4 light-shadow-2 p-2",
  position: "top"
};
var n, w, f, m, y, x, h, c, D, $, O, U, A, V, b, z, T, B;
class N extends _ {
  constructor(t, o) {
    super();
    p(this, D);
    p(this, O);
    p(this, A);
    p(this, b);
    p(this, T);
    E(this, "options");
    p(this, n, void 0);
    p(this, w, void 0);
    p(this, f, void 0);
    p(this, m, void 0);
    p(this, y, void 0);
    p(this, x, void 0);
    p(this, h, void 0);
    p(this, c, void 0);
    try {
      this.preventDbInstance(t), C.push({ type: "Tooltip", instance: this }), this.el = document.querySelector(t), this.options = P("Tooltip", o, this.el), this.setup();
    } catch (a) {
      console.error("[Axentix] Tooltip init error", a);
    }
  }
  setup() {
    if (!this.options.content)
      return console.error(`Tooltip #${this.el.id} : empty content.`);
    v(this.el, "tooltip.setup"), this.options.position = this.options.position.toLowerCase(), document.querySelectorAll(".tooltip").forEach((o) => {
      o.dataset.tooltipId && o.dataset.tooltipId === this.el.id && l(this, n, o);
    }), e(this, n) || l(this, n, document.createElement("div")), e(this, n).dataset.tooltipId !== this.el.id && (e(this, n).dataset.tooltipId = this.el.id), u(this, D, $).call(this), document.body.appendChild(e(this, n)), l(this, w, ["right", "left", "top", "bottom"]), e(this, w).includes(this.options.position) || (this.options.position = "top"), this.setupListeners(), this.updatePosition(), e(this, n).style.display = "none";
  }
  setupListeners() {
    l(this, f, u(this, b, z).bind(this)), l(this, m, u(this, T, B).bind(this)), l(this, y, this.updatePosition.bind(this)), this.el.addEventListener("mouseenter", e(this, f)), this.el.addEventListener("mouseleave", e(this, m)), window.addEventListener("resize", e(this, y));
  }
  removeListeners() {
    this.el.removeEventListener("mouseenter", e(this, f)), this.el.removeEventListener("mouseleave", e(this, m)), window.removeEventListener("resize", e(this, y)), l(this, f, void 0), l(this, m, void 0), l(this, y, void 0);
  }
  updatePosition() {
    l(this, h, this.el.getBoundingClientRect()), u(this, O, U).call(this), l(this, c, e(this, n).getBoundingClientRect()), u(this, A, V).call(this);
  }
  show() {
    e(this, n).style.display = "block", this.updatePosition(), clearTimeout(e(this, x)), l(this, x, setTimeout(() => {
      v(this.el, "tooltip.show");
      const t = this.options.position == "top" || this.options.position == "left" ? "-" : "", o = this.options.position == "top" || this.options.position == "bottom" ? "Y" : "X";
      e(this, n).style.transform = `translate${o}(${t}${this.options.offset})`, e(this, n).style.opacity = "1";
    }, this.options.animationDelay));
  }
  hide() {
    v(this.el, "tooltip.hide"), clearTimeout(e(this, x)), e(this, n).style.transform = "translate(0)", e(this, n).style.opacity = "0", l(this, x, setTimeout(() => {
      e(this, n).style.display = "none";
    }, this.options.animationDuration));
  }
  change(t) {
    this.options = P("Tooltip", t, this.el), e(this, w).includes(this.options.position) || (this.options.position = "top"), u(this, D, $).call(this), this.updatePosition();
  }
}
n = new WeakMap(), w = new WeakMap(), f = new WeakMap(), m = new WeakMap(), y = new WeakMap(), x = new WeakMap(), h = new WeakMap(), c = new WeakMap(), D = new WeakSet(), $ = function() {
  e(this, n).style.transform = "translate(0)", e(this, n).style.opacity = "0", e(this, n).className = "tooltip " + this.options.classes, e(this, n).style.transitionDuration = this.options.animationDuration + "ms", e(this, n).innerHTML = this.options.content;
}, O = new WeakSet(), U = function() {
  if (this.options.position == "top" || this.options.position == "bottom") {
    const o = this.options.position === "top" ? e(this, h).top : e(this, h).top + e(this, h).height;
    e(this, n).style.top = o + "px";
  } else
    this.options.position == "right" && (e(this, n).style.left = e(this, h).left + e(this, h).width + "px");
}, A = new WeakSet(), V = function() {
  this.options.position == "top" || this.options.position == "bottom" ? e(this, n).style.left = e(this, h).left + e(this, h).width / 2 - e(this, c).width / 2 + "px" : e(this, n).style.top = e(this, h).top + e(this, h).height / 2 - e(this, c).height / 2 + "px", this.options.position == "top" ? e(this, n).style.top = e(this, c).top - e(this, c).height + "px" : this.options.position == "left" && (e(this, n).style.left = e(this, h).left - e(this, c).width + "px");
  const o = window.scrollY, a = parseFloat(e(this, n).style.top);
  this.options.position === "top" ? e(this, n).style.top = o * 2 + a + "px" : e(this, n).style.top = o + a + "px";
}, b = new WeakSet(), z = function(t) {
  t.preventDefault(), this.show();
}, T = new WeakSet(), B = function(t) {
  t.preventDefault(), this.hide();
}, E(N, "getDefaultOptions", () => j);
Y({
  class: N,
  name: "Tooltip",
  dataDetection: !0
});
export {
  N as default
};
