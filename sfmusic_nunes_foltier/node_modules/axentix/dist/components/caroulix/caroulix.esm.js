var Lt = Object.defineProperty;
var bt = (e, s, t) => s in e ? Lt(e, s, { enumerable: !0, configurable: !0, writable: !0, value: t }) : e[s] = t;
var X = (e, s, t) => (bt(e, typeof s != "symbol" ? s + "" : s, t), t), it = (e, s, t) => {
  if (!s.has(e))
    throw TypeError("Cannot " + t);
};
var i = (e, s, t) => (it(e, s, "read from private field"), t ? t.call(e) : s.get(e)), a = (e, s, t) => {
  if (s.has(e))
    throw TypeError("Cannot add the same private member more than once");
  s instanceof WeakSet ? s.add(e) : s.set(e, t);
}, o = (e, s, t, n) => (it(e, s, "write to private field"), n ? n.call(e, t) : s.set(e, t), t), st = (e, s, t, n) => ({
  set _(h) {
    o(e, s, h, t);
  },
  get _() {
    return i(e, s, n);
  }
}), r = (e, s, t) => (it(e, s, "access private method"), t);
const G = [], q = {
  components: [],
  plugins: [],
  prefix: "ax",
  mode: ""
}, et = (e) => q.components.find((s) => s.name === e).class, lt = () => {
  const e = q.components.filter((t) => t.dataDetection), s = q.plugins.filter((t) => t.dataDetection);
  return [...e, ...s].map((t) => t.name);
}, Et = (e, s) => {
  if (!e.name || !e.class) {
    console.error(`[Axentix] Error registering ${s} : Missing required parameters.`);
    return;
  }
  if (q[s].some((t) => t.name === e.name)) {
    console.error(`[Axentix] Error registering ${s} : Already exist.`);
    return;
  }
  e.autoInit && (e.autoInit.selector = e.autoInit.selector += ":not(.no-axentix-init)"), q[s].push(e);
}, It = (e) => {
  Et(e, "components");
}, wt = (e) => e.replace(/[\w]([A-Z])/g, (s) => s[0] + "-" + s[1]).toLowerCase(), Tt = (e, s = "") => {
  const t = wt(e);
  return s ? s + "-" + t : t;
}, Ct = (e, s, t, n, h = "") => {
  const c = s[0].toUpperCase() + s.slice(1).toLowerCase();
  lt().includes(c) && t !== "Collapsible" && c !== "Sidenav" && (e[s] = et(c).getDefaultOptions());
  const f = h ? h + "-" + s : s, $ = ct(e[s], t, n, f);
  if (!(Object.keys($).length === 0 && e.constructor === Object))
    return $;
}, ct = (e, s, t, n = "") => Object.keys(e).reduce((h, c) => {
  if (typeof e[c] == "object" && e[c] !== null) {
    const f = Ct(e, c, s, t, n);
    f && (h[c] = f);
  } else if (e[c] !== null) {
    const f = "data-" + s.toLowerCase() + "-" + Tt(c, n);
    if (t.hasAttribute(f)) {
      const $ = t.getAttribute(f);
      h[c] = typeof e[c] == "number" ? Number($) : $, typeof e[c] == "boolean" && (h[c] = $ === "true");
    }
  }
  return h;
}, {}), Dt = (e, s) => {
  const t = Object.assign({}, et(e).getDefaultOptions());
  return ct(t, e, s);
}, Ot = () => {
  document.querySelectorAll("[data-ax]").forEach((s) => {
    let t = s.dataset.ax;
    if (t = t[0].toUpperCase() + t.slice(1).toLowerCase(), !lt().includes(t)) {
      console.error(
        `[Axentix] Error: ${t} component doesn't exist. 
 Did you forget to register him ?`,
        s
      );
      return;
    }
    try {
      const n = et(t);
      new n(`#${s.id}`);
    } catch (n) {
      console.error("[Axentix] Data: Unable to load " + t, n);
    }
  });
}, At = () => {
  try {
    new Axentix.Axentix("all");
  } catch (e) {
    console.error("[Axentix] Unable to auto init.", e);
  }
};
document.addEventListener("DOMContentLoaded", () => {
  document.documentElement.dataset.axentix && At(), Ot();
});
const dt = (...e) => e.reduce((s, t) => {
  for (let n in t)
    s[n] = typeof t[n] == "object" && t[n] !== null ? dt(s[n], t[n]) : t[n];
  return s;
}, {}), Rt = (e, s, t) => dt(et(e).getDefaultOptions(), Dt(e, t), s), b = (e, s, t) => {
  const n = new CustomEvent("ax." + s, {
    detail: t || {},
    bubbles: !0
  });
  e.dispatchEvent(n);
}, $t = () => "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0, kt = () => !!window.PointerEvent && "maxTouchPoints" in window.navigator && window.navigator.maxTouchPoints >= 0, Pt = () => $t() ? "touch" : kt() ? "pointer" : "mouse", Mt = (e) => {
  const s = G.find((t) => t.type !== "Toast" && "#" + t.instance.el.id === e);
  return s ? s.instance : !1;
}, rt = (e) => e.targetTouches && e.targetTouches.length >= 1 ? e.targetTouches[0].clientY : e.changedTouches && e.changedTouches.length >= 1 ? e.changedTouches[0].pageY : e.clientY, ht = (e) => e.targetTouches && e.targetTouches.length >= 1 ? e.targetTouches[0].clientX : e.changedTouches && e.changedTouches.length >= 1 ? e.changedTouches[0].pageX : e.clientX;
class St {
  constructor() {
    X(this, "el");
  }
  removeListeners() {
  }
  setupListeners() {
  }
  setup() {
  }
  preventDbInstance(s) {
    if (s && Mt(s))
      throw new Error(`Instance already exist on ${s}`);
  }
  sync() {
    b(this.el, "component.sync"), this.removeListeners(), this.setupListeners();
  }
  reset() {
    b(this.el, "component.reset"), this.removeListeners(), this.setup();
  }
  destroy() {
    b(this.el, "component.destroy"), this.removeListeners();
    const s = G.findIndex((t) => t.instance.el.id === this.el.id);
    G.splice(s, 1);
  }
}
const Nt = {
  animationDuration: 500,
  height: "",
  backToOpposite: !0,
  enableTouch: !0,
  indicators: {
    enabled: !1,
    isFlat: !1,
    customClasses: ""
  },
  autoplay: {
    enabled: !0,
    interval: 5e3,
    side: "right"
  }
};
var E, g, l, I, k, w, P, T, p, M, C, m, y, D, O, A, R, v, F, Y, u, z, d, J, pt, K, ft, H, nt, x, L, S, W, Q, vt, V, xt, _, gt, j, mt, tt, yt, U, ot, N, Z, B, at;
class ut extends St {
  constructor(t, n) {
    super();
    a(this, J);
    a(this, K);
    a(this, H);
    a(this, x);
    a(this, S);
    a(this, Q);
    a(this, V);
    a(this, _);
    a(this, j);
    a(this, tt);
    a(this, U);
    a(this, N);
    a(this, B);
    X(this, "options");
    X(this, "activeIndex");
    a(this, E, 0);
    a(this, g, !1);
    a(this, l, void 0);
    a(this, I, 0);
    a(this, k, 0);
    a(this, w, !1);
    a(this, P, !1);
    a(this, T, !1);
    a(this, p, 0);
    a(this, M, 0);
    a(this, C, void 0);
    a(this, m, void 0);
    a(this, y, void 0);
    a(this, D, void 0);
    a(this, O, void 0);
    a(this, A, void 0);
    a(this, R, void 0);
    a(this, v, void 0);
    a(this, F, 0);
    a(this, Y, 0);
    a(this, u, void 0);
    a(this, z, void 0);
    a(this, d, void 0);
    try {
      this.preventDbInstance(t), G.push({ type: "Caroulix", instance: this }), this.el = document.querySelector(t), this.options = Rt("Caroulix", n, this.el), this.setup();
    } catch (h) {
      console.error("[Axentix] Caroulix init error", h);
    }
  }
  setup() {
    b(this.el, "caroulix.setup"), this.options.autoplay.side = this.options.autoplay.side.toLowerCase(), ["right", "left"].includes(this.options.autoplay.side) || (this.options.autoplay.side = "right"), this.activeIndex = 0, o(this, E, 0), o(this, g, !1), o(this, d, Pt()), o(this, l, r(this, J, pt).call(this)), this.options.indicators.enabled && r(this, j, mt).call(this);
    const n = this.el.querySelector(".active");
    n ? this.activeIndex = i(this, l).indexOf(n) : i(this, l)[0].classList.add("active"), r(this, K, ft).call(this), i(this, I) === 0 && r(this, S, W).call(this), this.setupListeners(), this.options.autoplay.enabled && this.play();
  }
  setupListeners() {
    o(this, C, r(this, S, W).bind(this)), window.addEventListener("resize", i(this, C)), i(this, y) && (o(this, D, this.next.bind(this, 1)), i(this, y).addEventListener("click", i(this, D))), i(this, m) && (o(this, O, this.prev.bind(this, 1)), i(this, m).addEventListener("click", i(this, O))), this.options.enableTouch && (o(this, A, r(this, Q, vt).bind(this)), o(this, R, r(this, V, xt).bind(this)), o(this, v, r(this, _, gt).bind(this)), this.el.addEventListener(
      `${i(this, d)}${i(this, d) === "touch" ? "start" : "down"}`,
      i(this, A)
    ), this.el.addEventListener(`${i(this, d)}move`, i(this, R)), this.el.addEventListener(
      `${i(this, d)}${i(this, d) === "touch" ? "end" : "up"}`,
      i(this, v)
    ), this.el.addEventListener(
      i(this, d) === "pointer" ? "pointerleave" : "mouseleave",
      i(this, v)
    ));
  }
  removeListeners() {
    window.removeEventListener("resize", i(this, C)), o(this, C, void 0), i(this, y) && (i(this, y).removeEventListener("click", i(this, D)), o(this, D, void 0)), i(this, m) && (i(this, m).removeEventListener("click", i(this, O)), o(this, O, void 0)), this.options.enableTouch && (this.el.removeEventListener(
      `${i(this, d)}${i(this, d) === "pointer" ? "down" : "start"}`,
      i(this, A)
    ), this.el.removeEventListener(`${i(this, d)}move`, i(this, R)), this.el.removeEventListener(
      `${i(this, d)}${i(this, d) === "touch" ? "end" : "up"}`,
      i(this, v)
    ), this.el.removeEventListener(
      i(this, d) === "pointer" ? "pointerleave" : "mouseleave",
      i(this, v)
    ), o(this, A, void 0), o(this, R, void 0), o(this, v, void 0));
  }
  goTo(t) {
    if (t === this.activeIndex)
      return;
    (t > this.activeIndex ? "right" : "left") === "left" ? this.prev(Math.abs(this.activeIndex - t)) : this.next(Math.abs(this.activeIndex - t)), this.options.indicators.enabled && r(this, U, ot).call(this);
  }
  play() {
    !this.options.autoplay.enabled || (this.stop(), o(this, z, setInterval(() => {
      this.options.autoplay.side === "right" ? this.next(1, !1) : this.prev(1, !1);
    }, this.options.autoplay.interval)));
  }
  stop() {
    !this.options.autoplay.enabled || clearInterval(i(this, z));
  }
  next(t = 1, n = !0) {
    i(this, w) || this.activeIndex === i(this, l).length - 1 && !this.options.backToOpposite || (b(this.el, "caroulix.next", { step: t }), o(this, g, !0), n && this.options.autoplay.enabled && this.stop(), this.activeIndex < i(this, l).length - 1 ? this.activeIndex += t : this.options.backToOpposite && (this.activeIndex = 0), r(this, B, at).call(this), r(this, x, L).call(this), n && this.options.autoplay.enabled && this.play());
  }
  prev(t = 1, n = !0) {
    i(this, w) || this.activeIndex === 0 && !this.options.backToOpposite || (b(this.el, "caroulix.prev", { step: t }), o(this, g, !0), n && this.options.autoplay.enabled && this.stop(), this.activeIndex > 0 ? this.activeIndex -= t : this.options.backToOpposite && (this.activeIndex = i(this, l).length - 1), r(this, B, at).call(this), r(this, x, L).call(this), n && this.options.autoplay.enabled && this.play());
  }
}
E = new WeakMap(), g = new WeakMap(), l = new WeakMap(), I = new WeakMap(), k = new WeakMap(), w = new WeakMap(), P = new WeakMap(), T = new WeakMap(), p = new WeakMap(), M = new WeakMap(), C = new WeakMap(), m = new WeakMap(), y = new WeakMap(), D = new WeakMap(), O = new WeakMap(), A = new WeakMap(), R = new WeakMap(), v = new WeakMap(), F = new WeakMap(), Y = new WeakMap(), u = new WeakMap(), z = new WeakMap(), d = new WeakMap(), J = new WeakSet(), pt = function() {
  return Array.from(this.el.children).reduce((t, n) => (n.classList.contains("caroulix-item") && t.push(n), n.classList.contains("caroulix-prev") && o(this, m, n), n.classList.contains("caroulix-next") && o(this, y, n), t), []);
}, K = new WeakSet(), ft = function() {
  o(this, I, 0), o(this, k, 0), i(this, l).forEach((t) => {
    const n = t.querySelector("img, video");
    n && (st(this, I)._++, n.complete ? r(this, H, nt).call(this, n, !0) : (n.loadRef = r(this, H, nt).bind(this, n), n.addEventListener("load", n.loadRef)));
  });
}, H = new WeakSet(), nt = function(t, n) {
  st(this, k)._++, n || (t.removeEventListener("load", t.loadRef), t.loadRef = void 0), i(this, I) == i(this, k) && (r(this, S, W).call(this), r(this, x, L).call(this, !0));
}, x = new WeakSet(), L = function(t = !1) {
  const n = this.el.getBoundingClientRect().width;
  i(this, l).forEach((c, f) => {
    c.style.transform = `translateX(${n * f - n * this.activeIndex - i(this, E)}px)`;
  }), this.options.indicators.enabled && r(this, U, ot).call(this), i(this, l).find((c) => c.classList.contains("active")).classList.remove("active"), i(this, l)[this.activeIndex].classList.add("active"), setTimeout(() => {
    o(this, g, !1);
  }, this.options.animationDuration), t && setTimeout(() => r(this, N, Z).call(this, this.options.animationDuration), 50);
}, S = new WeakSet(), W = function() {
  if (o(this, w, !0), this.el.style.transitionDuration = "", this.options.autoplay.enabled && this.play(), this.options.height)
    this.el.style.height = this.options.height;
  else {
    const t = i(this, l).map((h) => h.offsetHeight), n = Math.max(...t);
    this.el.style.height = n + "px";
  }
  r(this, x, L).call(this), setTimeout(() => {
    this.el.style.transitionDuration = this.options.animationDuration + "ms", o(this, w, !1);
  }, 50);
}, Q = new WeakSet(), vt = function(t) {
  t.target.closest(".caroulix-arrow") || t.target.closest(".caroulix-indicators") || i(this, g) || (t.type !== "touchstart" && t.preventDefault(), this.options.autoplay.enabled && this.stop(), r(this, N, Z).call(this, 0), o(this, T, !0), o(this, P, !1), o(this, p, 0), o(this, M, 0), o(this, F, ht(t)), o(this, Y, rt(t)));
}, V = new WeakSet(), xt = function(t) {
  if (!i(this, T) || i(this, P))
    return;
  let n = ht(t), h = rt(t);
  if (o(this, p, i(this, F) - n), o(this, M, Math.abs(i(this, Y) - h)), t.type === "touchmove" && i(this, M) > Math.abs(i(this, p)))
    return o(this, P, !0), o(this, p, 0), !1;
  t.cancelable && t.preventDefault(), o(this, E, i(this, p)), r(this, x, L).call(this);
}, _ = new WeakSet(), gt = function(t) {
  if (!(t.target.closest(".caroulix-arrow") || t.target.closest(".caroulix-indicators")) && (t.cancelable && t.preventDefault(), i(this, T))) {
    r(this, N, Z).call(this, this.options.animationDuration);
    let n = this.el.getBoundingClientRect().width;
    o(this, T, !1);
    const h = n * 15 / 100;
    this.activeIndex !== i(this, l).length - 1 && i(this, p) > h ? this.next() : this.activeIndex !== 0 && i(this, p) < -h && this.prev(), o(this, p, 0), o(this, E, 0), r(this, x, L).call(this), this.options.autoplay.enabled && this.play();
  }
}, j = new WeakSet(), mt = function() {
  o(this, u, document.createElement("ul")), i(this, u).classList.add("caroulix-indicators"), this.options.indicators.isFlat && i(this, u).classList.add("caroulix-flat"), this.options.indicators.customClasses && (i(this, u).className = `${i(this, u).className} ${this.options.indicators.customClasses}`);
  for (let t = 0; t < i(this, l).length; t++) {
    const n = document.createElement("li");
    n.triggerRef = r(this, tt, yt).bind(this, t), n.addEventListener("click", n.triggerRef), i(this, u).appendChild(n);
  }
  this.el.appendChild(i(this, u));
}, tt = new WeakSet(), yt = function(t, n) {
  n.preventDefault(), t !== this.activeIndex && this.goTo(t);
}, U = new WeakSet(), ot = function() {
  Array.from(i(this, u).children).forEach((t) => t.removeAttribute("class")), i(this, u).children[this.activeIndex].classList.add("active");
}, N = new WeakSet(), Z = function(t) {
  this.el.style.transitionDuration = t + "ms";
}, B = new WeakSet(), at = function() {
  b(this.el, "caroulix.slide", {
    nextElement: i(this, l)[this.activeIndex],
    currentElement: i(this, l)[i(this, l).findIndex((t) => t.classList.contains("active"))]
  });
}, X(ut, "getDefaultOptions", () => Nt);
It({
  class: ut,
  name: "Caroulix",
  dataDetection: !0,
  autoInit: {
    enabled: !0,
    selector: ".caroulix"
  }
});
export {
  ut as default
};
