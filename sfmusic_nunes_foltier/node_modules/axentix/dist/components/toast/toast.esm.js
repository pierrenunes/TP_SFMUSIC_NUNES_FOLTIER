var tt = Object.defineProperty;
var et = (i, t, e) => t in i ? tt(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e;
var v = (i, t, e) => (et(i, typeof t != "symbol" ? t + "" : t, e), e), q = (i, t, e) => {
  if (!t.has(i))
    throw TypeError("Cannot " + e);
};
var o = (i, t, e) => (q(i, t, "read from private field"), e ? e.call(i) : t.get(i)), n = (i, t, e) => {
  if (t.has(i))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(i) : t.set(i, e);
}, a = (i, t, e, s) => (q(i, t, "write to private field"), s ? s.call(i, e) : t.set(i, e), e);
var r = (i, t, e) => (q(i, t, "access private method"), e);
const E = [], f = {
  components: [],
  plugins: [],
  prefix: "ax",
  mode: ""
}, T = (i) => `--${f.prefix}-${i}`, it = (i) => f.components.find((t) => t.name === i).class, st = () => {
  const i = f.components.filter((e) => e.dataDetection), t = f.plugins.filter((e) => e.dataDetection);
  return [...i, ...t].map((e) => e.name);
}, ot = (i, t) => {
  if (!i.name || !i.class) {
    console.error(`[Axentix] Error registering ${t} : Missing required parameters.`);
    return;
  }
  if (f[t].some((e) => e.name === i.name)) {
    console.error(`[Axentix] Error registering ${t} : Already exist.`);
    return;
  }
  i.autoInit && (i.autoInit.selector = i.autoInit.selector += ":not(.no-axentix-init)"), f[t].push(i);
}, nt = (i) => {
  ot(i, "components");
}, rt = () => {
  document.querySelectorAll("[data-ax]").forEach((t) => {
    let e = t.dataset.ax;
    if (e = e[0].toUpperCase() + e.slice(1).toLowerCase(), !st().includes(e)) {
      console.error(
        `[Axentix] Error: ${e} component doesn't exist. 
 Did you forget to register him ?`,
        t
      );
      return;
    }
    try {
      const s = it(e);
      new s(`#${t.id}`);
    } catch (s) {
      console.error("[Axentix] Data: Unable to load " + e, s);
    }
  });
}, at = () => {
  try {
    new Axentix.Axentix("all");
  } catch (i) {
    console.error("[Axentix] Unable to auto init.", i);
  }
};
document.addEventListener("DOMContentLoaded", () => {
  document.documentElement.dataset.axentix && at(), rt();
});
const H = (...i) => i.reduce((t, e) => {
  for (let s in e)
    t[s] = typeof e[s] == "object" && e[s] !== null ? H(t[s], e[s]) : e[s];
  return t;
}, {}), w = (i, t, e) => {
  const s = new CustomEvent("ax." + t, {
    detail: e || {},
    bubbles: !0
  });
  i.dispatchEvent(s);
}, lt = () => "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0, ct = () => !!window.PointerEvent && "maxTouchPoints" in window.navigator && window.navigator.maxTouchPoints >= 0, ht = () => lt() ? "touch" : ct() ? "pointer" : "mouse", dt = (i) => E.filter((t) => t.type === i).map((t) => t.instance), D = (i) => i.targetTouches && i.targetTouches.length >= 1 ? i.targetTouches[0].clientX : i.changedTouches && i.changedTouches.length >= 1 ? i.changedTouches[0].pageX : i.clientX, pt = {
  animationDuration: 400,
  duration: 4e3,
  classes: "",
  position: "right",
  direction: "top",
  mobileDirection: "bottom",
  offset: { x: "5%", y: "0%", mobileX: "10%", mobileY: "0%" },
  isClosable: !1,
  isSwipeable: !0,
  closableContent: "x",
  loading: {
    enabled: !0,
    border: "2px solid #E2E2E2"
  }
};
var u, l, c, x, b, m, h, d, L, Y, P, z, A, F, $, V, S, G, M, J, R, K, O, Q, k, W, I, Z, X, _, B, j, p, y;
const N = class {
  constructor(t, e) {
    n(this, L);
    n(this, P);
    n(this, A);
    n(this, $);
    n(this, S);
    n(this, M);
    n(this, R);
    n(this, O);
    n(this, k);
    n(this, I);
    n(this, X);
    n(this, B);
    n(this, p);
    v(this, "options");
    v(this, "id");
    n(this, u, void 0);
    n(this, l, void 0);
    n(this, c, void 0);
    n(this, x, void 0);
    n(this, b, void 0);
    n(this, m, void 0);
    n(this, h, void 0);
    n(this, d, void 0);
    if (dt("Toast").length > 0) {
      console.error("[Axentix] Toast: Don't try to create multiple toast instances");
      return;
    }
    E.push({ type: "Toast", instance: this }), this.id = Math.random().toString().split(".")[1], a(this, u, t), this.options = H(N.getDefaultOptions(), e), a(this, c, ht()), this.options.position = this.options.position.toLowerCase(), this.options.direction = this.options.direction.toLowerCase(), this.options.mobileDirection = this.options.mobileDirection.toLowerCase(), a(this, l, {});
  }
  destroy() {
    const t = E.findIndex((e) => e.instance.id === this.id);
    E.splice(t, 1);
  }
  show() {
    try {
      Object.keys(o(this, l)).includes(this.options.position) || r(this, L, Y).call(this), r(this, B, j).call(this);
    } catch (t) {
      console.error("[Axentix] Toast error", t);
    }
  }
  change(t, e) {
    a(this, u, t), this.options = H(this.options, e);
  }
};
let C = N;
u = new WeakMap(), l = new WeakMap(), c = new WeakMap(), x = new WeakMap(), b = new WeakMap(), m = new WeakMap(), h = new WeakMap(), d = new WeakMap(), L = new WeakSet(), Y = function() {
  let t = document.createElement("div");
  ["right", "left"].includes(this.options.position) || (this.options.position = "right"), this.options.position === "right" ? t.style.right = this.options.offset.x : t.style.left = this.options.offset.x;
  const s = ["bottom", "top"];
  s.includes(this.options.direction) || (this.options.direction = "top"), this.options.direction === "top" ? t.style.top = this.options.offset.y : t.style.bottom = this.options.offset.y, s.includes(this.options.mobileDirection) || (this.options.mobileDirection = "bottom"), t.style.setProperty(
    T("toaster-m-width"),
    100 - this.options.offset.mobileX.slice(0, -1) + "%"
  ), t.style.setProperty(T("toaster-m-offset"), this.options.offset.mobileY), this.options.loading.enabled && t.style.setProperty(T("toast-loading-border"), this.options.loading.border), t.className = `toaster toaster-${this.options.position} toast-${this.options.direction} toaster-m-${this.options.mobileDirection}`, o(this, l)[this.options.position] = t, document.body.appendChild(t);
}, P = new WeakSet(), z = function() {
  for (const t in o(this, l)) {
    let e = o(this, l)[t];
    e.childElementCount <= 0 && (e.remove(), delete o(this, l)[t]);
  }
}, A = new WeakSet(), F = function(t) {
  setTimeout(() => {
    w(t, "toast.show"), this.options.loading.enabled && (t.classList.add("toast-loading"), t.style.setProperty(T("toast-loading-duration"), this.options.duration + "ms")), t.classList.add("toast-animated"), setTimeout(() => {
      w(t, "toast.shown"), this.options.loading.enabled && t.classList.add("toast-load");
    }, this.options.animationDuration);
  }, 50);
}, $ = new WeakSet(), V = function(t) {
  setTimeout(() => {
    w(t, "toast.hide"), r(this, p, y).call(this, t);
  }, this.options.duration + this.options.animationDuration);
}, S = new WeakSet(), G = function(t) {
  t.style.transitionTimingFunction = "cubic-bezier(0.445, 0.05, 0.55, 0.95)", t.style.paddingTop = "0", t.style.paddingBottom = "0", t.style.margin = "0", t.style.height = "0";
}, M = new WeakSet(), J = function(t) {
  a(this, x, r(this, O, Q).bind(this)), a(this, b, r(this, k, W).bind(this)), a(this, m, r(this, I, Z).bind(this)), t.addEventListener(
    `${o(this, c)}${o(this, c) === "touch" ? "start" : "down"}`,
    o(this, x)
  ), t.addEventListener(`${o(this, c)}move`, o(this, b)), t.addEventListener(
    `${o(this, c)}${o(this, c) === "touch" ? "end" : "up"}`,
    o(this, m)
  ), t.addEventListener(
    o(this, c) === "pointer" ? "pointerleave" : "mouseleave",
    o(this, m)
  );
}, R = new WeakSet(), K = function(t) {
  t.querySelectorAll("[data-toast-close]").forEach((e) => {
    e.addEventListener("click", () => {
      r(this, p, y).call(this, t);
    });
  });
}, O = new WeakSet(), Q = function(t) {
  if (t.target.closest(".toast-trigger"))
    return;
  const e = t.target.closest(".toast");
  e.dataset.closing || (a(this, d, D(t)), a(this, h, !0), e.style.transitionProperty = "height, margin, padding, transform, box-shadow");
}, k = new WeakSet(), W = function(t) {
  if (!o(this, h))
    return;
  const e = t.target.closest(".toast"), s = e.getBoundingClientRect(), g = Math.abs(D(t) - o(this, d));
  e.style.left = D(t) - o(this, d) + "px", e.style.opacity = g < s.width ? (0.99 - g / s.width).toString() : "0.01";
}, I = new WeakSet(), Z = function(t) {
  if (!o(this, h))
    return;
  t.cancelable && t.preventDefault(), a(this, h, !1);
  const e = t.target.closest(".toast");
  e.style.transitionProperty = "height, margin, opacity, padding, transform, box-shadow, left", Math.abs(D(t) - o(this, d)) > e.getBoundingClientRect().width / 2 ? (r(this, p, y).call(this, e), e.dataset.closing = "true") : (e.style.left = "0px", e.style.opacity = 1);
}, X = new WeakSet(), _ = function(t) {
  r(this, M, J).call(this, t);
}, B = new WeakSet(), j = function() {
  let t = document.createElement("div");
  if (t.className = "toast shadow-1 " + this.options.classes, t.innerHTML = o(this, u), t.style.transitionDuration = this.options.animationDuration + "ms", this.options.isClosable) {
    let s = document.createElement("div");
    s.className = "toast-trigger", s.innerHTML = this.options.closableContent, s.listenerRef = r(this, p, y).bind(this, t, s), s.addEventListener("click", s.listenerRef), t.appendChild(s);
  }
  this.options.isSwipeable && r(this, X, _).call(this, t), r(this, A, F).call(this, t), r(this, R, K).call(this, t), o(this, l)[this.options.position].appendChild(t), r(this, $, V).call(this, t);
  const e = t.clientHeight;
  t.style.height = e + "px";
}, p = new WeakSet(), y = function(t, e, s) {
  if (t.isAnimated)
    return;
  let g = 1;
  s && (s.preventDefault(), g = 0, this.options.isClosable && e.removeEventListener("click", e.listenerRef)), t.style.opacity = "0", t.isAnimated = !0;
  const U = g * this.options.animationDuration + this.options.animationDuration;
  setTimeout(() => {
    r(this, S, G).call(this, t);
  }, U / 2), setTimeout(() => {
    t.remove(), w(t, "toast.remove"), r(this, P, z).call(this);
  }, U * 1.45);
}, v(C, "getDefaultOptions", () => pt);
nt({
  class: C,
  name: "Toast"
});
export {
  C as default
};
